{"version":3,"sources":["../source/common.js"],"names":["parseDigit","parse_phone_number_digits","parse_national_number_and_country_calling_code","matches_entirely","create_extension_pattern","DASHES","SLASHES","DOTS","WHITESPACE","BRACKETS","TILDES","VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","LEADING_PLUS_CHARS_PATTERN","RegExp","MAX_LENGTH_FOR_NSN","MAX_LENGTH_COUNTRY_CODE","DIGITS","character","number","test","drop_and_substitute_characters","country","metadata","numberWithoutIDD","i","length","countryCallingCode","slice","countryCallingCodes","text","regular_expression","matched_groups","match","replacements","replaced","split","replacement","toUpperCase","RFC3966_EXTN_PREFIX","CAPTURING_EXTN_DIGITS","purpose","single_extension_characters"],"mappings":"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","file":"common.js","sourcesContent":["import { stripIDDPrefix } from './IDD'\r\n\r\n// `DASHES` will be right after the opening square bracket of the \"character class\"\r\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\r\nconst SLASHES = '\\uFF0F/'\r\nconst DOTS = '\\uFF0E.'\r\nexport const WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\r\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\r\n// export const OPENING_BRACKETS = '(\\uFF08\\uFF3B\\\\\\['\r\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\r\n\r\n// Digits accepted in phone numbers\r\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\r\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\r\n\r\n// Regular expression of acceptable punctuation found in phone numbers. This\r\n// excludes punctuation found as a leading character only. This consists of dash\r\n// characters, white space characters, full stops, slashes, square brackets,\r\n// parentheses and tildes. Full-width variants are also present.\r\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\r\n\r\nexport const PLUS_CHARS = '+\\uFF0B'\r\nconst LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')\r\n\r\n// The ITU says the maximum length should be 15,\r\n// but one can find longer numbers in Germany.\r\nexport const MAX_LENGTH_FOR_NSN = 17\r\n\r\n// The maximum length of the country calling code.\r\nexport const MAX_LENGTH_COUNTRY_CODE = 3\r\n\r\n// These mappings map a character (key) to a specific digit that should\r\n// replace it for normalization purposes. Non-European digits that\r\n// may be used in phone numbers are mapped to a European equivalent.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n//\r\nexport const DIGITS =\r\n{\r\n\t'0': '0',\r\n\t'1': '1',\r\n\t'2': '2',\r\n\t'3': '3',\r\n\t'4': '4',\r\n\t'5': '5',\r\n\t'6': '6',\r\n\t'7': '7',\r\n\t'8': '8',\r\n\t'9': '9',\r\n\t'\\uFF10': '0', // Fullwidth digit 0\r\n\t'\\uFF11': '1', // Fullwidth digit 1\r\n\t'\\uFF12': '2', // Fullwidth digit 2\r\n\t'\\uFF13': '3', // Fullwidth digit 3\r\n\t'\\uFF14': '4', // Fullwidth digit 4\r\n\t'\\uFF15': '5', // Fullwidth digit 5\r\n\t'\\uFF16': '6', // Fullwidth digit 6\r\n\t'\\uFF17': '7', // Fullwidth digit 7\r\n\t'\\uFF18': '8', // Fullwidth digit 8\r\n\t'\\uFF19': '9', // Fullwidth digit 9\r\n\t'\\u0660': '0', // Arabic-indic digit 0\r\n\t'\\u0661': '1', // Arabic-indic digit 1\r\n\t'\\u0662': '2', // Arabic-indic digit 2\r\n\t'\\u0663': '3', // Arabic-indic digit 3\r\n\t'\\u0664': '4', // Arabic-indic digit 4\r\n\t'\\u0665': '5', // Arabic-indic digit 5\r\n\t'\\u0666': '6', // Arabic-indic digit 6\r\n\t'\\u0667': '7', // Arabic-indic digit 7\r\n\t'\\u0668': '8', // Arabic-indic digit 8\r\n\t'\\u0669': '9', // Arabic-indic digit 9\r\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\r\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\r\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\r\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\r\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\r\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\r\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\r\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\r\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\r\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\r\n}\r\n\r\nexport function parseDigit(character)\r\n{\r\n\treturn DIGITS[character]\r\n}\r\n\r\n/**\r\n * Drops all punctuation leaving only digits and the leading `+` sign (if any).\r\n * Also converts wide-ascii and arabic-indic numerals to conventional numerals.\r\n *\r\n * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n *\r\n * @param  {string} number\r\n * @return {string}\r\n */\r\nexport function parse_phone_number_digits(number)\r\n{\r\n\treturn (LEADING_PLUS_CHARS_PATTERN.test(number) ? '+' : '') +\r\n\t\tdrop_and_substitute_characters(number, DIGITS)\r\n}\r\n\r\n// Parses a formatted phone number\r\n// and returns `{ country_calling_code, number }`\r\n// where `number` is the national (significant) phone number.\r\n//\r\n// (aka `maybeExtractCountryPhoneCode`)\r\n//\r\nexport function parse_national_number_and_country_calling_code(number, country, metadata)\r\n{\r\n\tnumber = parse_phone_number_digits(number)\r\n\r\n\tif (!number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then don't extract country phone code.\r\n\tif (number[0] !== '+')\r\n\t{\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIDDPrefix(number, country, metadata.metadata)\r\n\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\treturn { number }\r\n\t\t}\r\n\t}\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0')\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\r\n\t{\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\r\n\t\tif (metadata.countryCallingCodes()[countryCallingCode])\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n// Checks whether the entire input sequence can be matched\r\n// against the regular expression.\r\nexport function matches_entirely(text = '', regular_expression)\r\n{\r\n\tif (typeof regular_expression === 'string')\r\n\t{\r\n\t\tregular_expression = '^(?:' + regular_expression + ')$'\r\n\t}\r\n\r\n\tconst matched_groups = text.match(regular_expression)\r\n\treturn matched_groups !== null && matched_groups[0].length === text.length\r\n}\r\n\r\n// For any character not being part of `replacements`\r\n// it is removed from the phone number.\r\nfunction drop_and_substitute_characters(text, replacements)\r\n{\r\n\tlet replaced = ''\r\n\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for `digits` it is safe.\r\n\t// for (const character of text)\r\n\tfor (const character of text.split(''))\r\n\t{\r\n\t\tconst replacement = replacements[character.toUpperCase()]\r\n\r\n\t\tif (replacement)\r\n\t\t{\r\n\t\t\treplaced += replacement\r\n\t\t}\r\n\t}\r\n\r\n\treturn replaced\r\n}\r\n\r\n// The RFC 3966 format for extensions.\r\nconst RFC3966_EXTN_PREFIX = ';ext='\r\n\r\n// Pattern to capture digits used in an extension.\r\n// Places a maximum length of '7' for an extension.\r\nconst CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})'\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nexport function create_extension_pattern(purpose)\r\n{\r\n\t// One-character symbols that can be used to indicate an extension.\r\n\tlet single_extension_characters = 'x\\uFF58#\\uFF03~\\uFF5E'\r\n\r\n\tswitch (purpose)\r\n\t{\r\n\t\t// For parsing, we are slightly more lenient in our interpretation than for matching. Here we\r\n\t\t// allow \"comma\" and \"semicolon\" as possible extension indicators. When matching, these are\r\n\t\tcase 'parsing':\r\n\t\t\tsingle_extension_characters = ',;' + single_extension_characters\r\n\t}\r\n\r\n\treturn RFC3966_EXTN_PREFIX +\r\n\t\tCAPTURING_EXTN_DIGITS + '|' +\r\n\t\t'[ \\u00A0\\\\t,]*' +\r\n\t\t'(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' +\r\n\t\t'[' + single_extension_characters + ']|int|anexo|\\uFF49\\uFF4E\\uFF54)' +\r\n\t\t'[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*' +\r\n\t\tCAPTURING_EXTN_DIGITS + '#?|' +\r\n\t\t'[- ]+([' + VALID_DIGITS + ']{1,5})#'\r\n}"]}